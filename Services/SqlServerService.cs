using DamnORM.Helpers;
using DamnORM.Model.Exceptions;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Linq.Expressions;
using System.Text;

namespace DamnORM.Services
{
    /// <summary>
    /// Helper class for accessing SQL server
    /// </summary>
    public class SqlServerService
    {
        /// <summary>
        /// Gets or sets the connection string.
        /// </summary>
        public string ConnectionString { get; set; }

        /// <summary>
        /// Selects a single record/row from a table.
        /// </summary>
        /// <typeparam name="T">
        ///     A CLR class/struct reprsenting the table definition.
        ///     <para>
        ///         T must be decorated using the
        ///         <see cref="DamnORM.Model.Attributes.DbTableAttribute" /> and
        ///         <see cref="DamnORM.Model.Attributes.DbColumnAttribute" /> respectively.
        ///     </para>
        /// </typeparam>
        /// <param name="whereExpression">The where expression.</param>
        /// <returns>An object of type T</returns>
        public T Select<T>(Expression<Func<T, bool>> where = null)
        {
            return SelectMany<T>(1, where).FirstOrDefault();
        }

        public IEnumerable<T> SelectMany<T>(uint numOfRecords = 1, Expression<Func<T, bool>> where = null)
        {
            var query = new StringBuilder();
            var reflectionData = ReflectionHelper.GetTableMetadata<T>();
            var whereExpression = ExpressionParseHelper<T>.Parse(where);
            IDictionary<string, object> parameters = null;

            query.Append("SELECT TOP ")
                .Append(numOfRecords)
                .Append(" ")
                .Append("[")
                .Append(string.Join("], [", reflectionData.ColumnNames))
                .Append("] FROM ")
                .Append(reflectionData.TableName);

            if (whereExpression != null)
            {
                query.Append(" WHERE ").Append(whereExpression);
                parameters = whereExpression.ParameterValues;
            }

            return ExecuteReader(query.ToString(), parameters)
                .ForEach(reader => ReflectionHelper.CreateInstance<T>(reader, reflectionData.Columns));
        }

        /// <summary>
        /// Inserts the specified object into a table.
        /// </summary>
        /// <typeparam name="T">
        ///     A CLR class/struct reprsenting the table definition.
        ///     <para>
        ///         T must be decorated using the
        ///         <see cref="DamnORM.Model.Attributes.DbTableAttribute" /> and
        ///         <see cref="DamnORM.Model.Attributes.DbColumnAttribute" /> respectively.
        ///     </para>
        /// </typeparam>
        /// <param name="obj">The object to insert.</param>
        /// <returns>The inserted object with it's Auto generated fields updated.</returns>
        public T Insert<T>(T obj)
        {
            return InsertMany<T>(obj).FirstOrDefault();
        }

        /// <summary>
        /// Inserts one or more objects into a table.
        /// </summary>
        /// <typeparam name="T">
        ///     A CLR class/struct reprsenting the table definition.
        ///     <para>
        ///         T must be decorated using the
        ///         <see cref="DamnORM.Model.Attributes.DbTableAttribute" /> and
        ///         <see cref="DamnORM.Model.Attributes.DbColumnAttribute" /> respectively.
        ///     </para>
        /// </typeparam>
        /// <param name="values">The objects to insert.</param>
        /// <returns>All the inserted objects with their Auto generated fields updated.</returns>
        /// <exception cref="SqlServerServiceException">No item to insert</exception>
        public IEnumerable<T> InsertMany<T>(params T[] values)
        {
            // TODO: Validate Data
            if (values.Length <= 0)
                throw new SqlServerServiceException("No item to insert");

            var query = new StringBuilder();
            var reflectionData = ReflectionHelper.GetTableMetadata<T>();

            DataValidationHelper.AssertStringsNotTooLong(reflectionData, values);

            var insertColumns = string.Format("([{0}])",
                string.Join("], [", reflectionData.NonAutoGeneratedColumnNames));
            var outputColumns = string.Format("INSERTED.{0}",
                string.Join(", INSERTED.", reflectionData.AutoGeneratedColumnNames));

            // TODO: Optimize parameters, if same values in column, use one parameter
            var insertParametersWithTheirValues = values.ForEach((value, index) =>
                reflectionData.NonAutoGeneratedColumns.ToDictionary(
                    col => string.Format("@{0}_{1}", col.Attribute.ColumnName, index),
                    col => ReflectionHelper.GetPropertyValue(value, col.BackingPropertyName)
                ));

            var insertParameters = insertParametersWithTheirValues
                .Select(row => string.Format("({0})", string.Join(", ", row.Keys)));

            query.AppendFormat("INSERT INTO {0} {1} ", reflectionData.TableName, insertColumns);
            query.AppendFormat("OUTPUT {0} ", outputColumns);
            query.AppendFormat("VALUES {0} ", string.Join(",", insertParameters));

            var @params = insertParametersWithTheirValues.ToArray();

            return ExecuteReader(query.ToString(), @params)
                .ForEach((reader, index) => ReflectionHelper.SetProperties(
                    ref values[index],
                    reader,
                    reflectionData.AutoGeneratedColumns
                ));
        }

        /// <summary>
        /// Updates row(s) in a table with the specified object.
        /// </summary>
        /// <typeparam name="T">
        ///     A CLR class/struct reprsenting the table definition.
        ///     <para>
        ///         T must be decorated using the
        ///         <see cref="DamnORM.Model.Attributes.DbTableAttribute" /> and
        ///         <see cref="DamnORM.Model.Attributes.DbColumnAttribute" /> respectively.
        ///     </para>
        /// </typeparam>
        /// <param name="obj">The object to update.</param>
        /// <param name="whereExpression">The where expression to match rows to update.</param>
        /// <returns>Number of update columns</returns>
        public int Update<T>(T obj, Expression<Func<T, bool>> where = null)
        {
            // TODO: Validate Data
            var reflectionData = ReflectionHelper.GetTableMetadata<T>(obj);

            return UpdateColumns<T>(reflectionData.NonAutoGeneratedColumns.ToDictionary(
                    column => column.Attribute.ColumnName,
                    column => column.BackingPropertyValue
                ),
                where);
        }

        /// <summary>
        /// Updates the specified columns in a table.
        /// </summary>
        /// <typeparam name="T">
        ///     A CLR class/struct reprsenting the table definition.
        ///     <para>
        ///         T must be decorated using the
        ///         <see cref="DamnORM.Model.Attributes.DbTableAttribute" /> and
        ///         <see cref="DamnORM.Model.Attributes.DbColumnAttribute" /> respectively.
        ///     </para>
        /// </typeparam>
        /// <param name="fieldValues">The column-value pair.</param>
        /// <param name="whereExpression">The where expression to match rows to update.</param>
        /// <returns>Number of update columns</returns>
        public int UpdateColumns<T>(IDictionary<string, object> fieldValues, Expression<Func<T, bool>> where = null)
        {
            var query = new StringBuilder();
            var reflectionData = ReflectionHelper.GetTableMetadata<T>();
            var whereExpression = ExpressionParseHelper<T>.Parse(where);

            fieldValues.ForEach(entry =>
            {
                DataValidationHelper.AssertStringNotTooLong(reflectionData[entry.Key], entry.Value);
            });

            var valuesToSet = fieldValues.Keys.Select(column => string.Format("[{0}] = @{0}", column));

            query.AppendFormat("UPDATE [{0}] SET {1} WHERE {2}",
                reflectionData.TableName,
                string.Join(",", valuesToSet),
                whereExpression);

            return ExecuteNonQuery(query.ToString(), whereExpression.ParameterValues, fieldValues);
        }

        /// <summary>
        /// Invokes a stored procedure.
        /// </summary>
        /// <typeparam name="T">
        ///     A CLR class/struct reprsenting the table definition.
        ///     <para>
        ///         T must be decorated using the
        ///         <see cref="DamnORM.Model.Attributes.DbTableAttribute" /> and
        ///         <see cref="DamnORM.Model.Attributes.DbColumnAttribute" /> respectively.
        ///     </para>
        /// </typeparam>
        /// <param name="procedureName">Name of the stored procedure.</param>
        /// <param name="parameters">The parameters.</param>
        /// <returns>One or more objects of type T</returns>
        public IEnumerable<T> InvokeStoredProcedure<T>(string procedureName, Dictionary<string, object> parameters = null)
        {
            var columns = ReflectionHelper.GetTableMetadata<T>().Columns;
            var columnValueMappings = InvokeStoredProcedureGeneric(procedureName, parameters);

            foreach (var columnValueMapping in columnValueMappings)
            {
                yield return ReflectionHelper.CreateInstance<T>(columnValueMapping, columns);
            }

            yield break;
        }

        /// <summary>
        /// Invokes a stored procedure.
        /// </summary>
        /// <param name="procedureName">Name of the stored procedure.</param>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Results from the stored procedure as a collection of key-value pair, per row.</returns>
        public IEnumerable<Dictionary<string, object>> InvokeStoredProcedureGeneric(string procedureName, Dictionary<string, object> parameters = null)
        {
            var dataSet = new DataSet();

            using (var conn = new SqlConnection(ConnectionString))
            {
                conn.Open();

                using (var cmd = new SqlCommand(procedureName, conn))
                {
                    cmd.CommandType = CommandType.StoredProcedure;

                    if (parameters != null)
                    {
                        foreach (var arg in parameters)
                        {
                            cmd.Parameters.AddWithValue(arg.Key, arg.Value);
                        }
                    }

                    using (var dataReader = cmd.ExecuteReader())
                    {
                        while (dataReader.HasRows && dataReader.Read())
                        {
                            var row = new Dictionary<string, object>();

                            for (int i = 0; i < dataReader.FieldCount; i++)
                            {
                                row.Add(dataReader.GetName(i), dataReader[i]);
                            }

                            yield return row;
                        }
                    }
                }
            }

            yield break;
        }

        /// <summary>
        /// Executes a T-SQL query, then returns a handle for reading the result.
        /// </summary>
        /// <param name="query">The query.</param>
        /// <param name="parameters">The parameters.</param>
        /// <returns>A collection of IDataReader for reading the results</returns>
        public IEnumerable<IDataReader> ExecuteReader(string query, params IDictionary<string, object>[] parameters)
        {
            return ExecuteQuery<IDataReader>(query, parameters);
        }

        /// <summary>
        /// Executes a T-SQL query, then returns the number of affected rows.
        /// </summary>
        /// <param name="query">The query.</param>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Number of affected rows</returns>
        public int ExecuteNonQuery(string query, params IDictionary<string, object>[] parameters)
        {
            var numberOfAffectedRows = ExecuteQuery<object>(query, parameters).FirstOrDefault() as int?;
            return numberOfAffectedRows ?? 0;
        }

        /// <summary>
        /// Executes the T-SQL query.
        /// </summary>
        /// <typeparam name="T">
        ///     Indicates what type of result to return. <para />
        ///     IDataReader, for returning a SqlDataReader <para />
        ///     object, for the number of affected rows.
        /// </typeparam>
        /// <param name="query">The query.</param>
        /// <param name="parameters">The parameters.</param>
        /// <returns>DataReader, OR number of affected rows.</returns>
        private IEnumerable<T> ExecuteQuery<T>(string query, params IDictionary<string, object>[] parameters) where T : class
        {
            using (var conn = new SqlConnection(this.ConnectionString))
            {
                conn.Open();

                using (var cmd = new SqlCommand(query.ToString(), conn))
                {
                    if (parameters != null)
                    {
                        parameters.IsNotDefault()
                            .ForEach(@params =>
                            {
                                foreach (var param in @params)
                                {
                                    cmd.Parameters.AddWithValue(param.Key, param.Value);
                                }
                            });
                    }

                    if (typeof(T) == typeof(object))
                    {
                        yield return cmd.ExecuteNonQuery() as T;
                    }

                    if (typeof(T).IsAssignableFrom(typeof(IDataReader)))
                    {
                        using (var dataReader = cmd.ExecuteReader())
                        {
                            while (dataReader != null && dataReader.HasRows && dataReader.Read())
                            {
                                yield return dataReader as T;
                            }
                        }
                    }
                }
            }

            yield break;
        }
    }
}